# Chapter 13 Copy Control

## Exercise 13.1

Copy constructor is a constructor with its first parameter as reference type, and other parameters with default values.

Here are conditions that copy/move constructor are used:

- Define variables using an =
- Pass an object as an argument to a parameter of nonreference type
- Return an object from a function that has a nonreference return type
- Brace initialize the elements in an array or the members of an aggregate class
- Some class types also use copy initialization for the objects they allocate.


## Exercise 13.2

If we use this as copy constructor, we'll have to use its copy constructor to initialize the item in parameter list (rhs in this case), so the copy constructor is defined recursively.

## Exercise 13.3

(By Mooophy)

When we copy a StrBlob, the shared_ptr member's use_count add one.

When we copy a StrBlobPrts, the weak_ptr member's use_count isn't changed.(Because the count belongs to shared_ptr)

## Exercise 13.4

Copy constructor is called in expressions with a check mark.

```
Point global;
Point foo_bar(Point arg) // Check
{
    Point local = arg, *heap = new Point(global); // Check, Check
    *heap = local;
    Point pa[ 4 ] = { local, *heap }; // Check, Check
    return *heap; // Check
}
```

## Exercise 13.5

```
HasPtr(const HasPtr& hp) : ps(new std::string(*hp.ps)), i(hp.i) { }

```

## Exercise 13.6

(By Mooophy)
The copy-assignment operator is function named operator=.

This operator is used when assignment occurred.

The synthesized copy-assignment operator assigns each nonstatic member of the right-hand object to corresponding member of the left-hand object using the copy-assignment operator for the type of that member.

It is synthesized when the class does not define its own.

## Exercise 13.7
In both cases, shallow copy will happen. All pointers 
point to the same address. The use_count changed the same as 13.3.

## Exercise 13.8
```
HasPtr& operator=(const HasPtr &hp) {
        std::string *new_ps = new std::string(*hp.ps);
        delete ps;
        ps = new_ps;
        i = hp.i;
        return *this;
    }
```
## Exercise 13.9

(By Mooophy)
The destructor is a member function with the name of the class prefixed by a tilde(~).

As with the copy constructor and the copy-assignment operator, for some classes, the synthesized destructor is defined to disallow objects of the type from being destoryed. Otherwise, the synthesized destructor has an empty function body.

The compiler defines a synthesized destructor for any class that does not define its own destructor.

## Exercise 13.10
StrBlob is destroyed safely, as use_count weill decrement. It will be automaticly freed if no pointer to that dynamic object exist.
StrBlobPtr will not be freed by a compiler synthesised destructor.

## Exercise 13.11
```
 ~HasPtr() {
        delete ps;
    }
```

## Exercise 13.12
Three go out scope: accum, item1, item2.

*trans will not be deleted.

## Exercise 13.13
(By Moophy)

Test program:

```
struct X {
    X() { std::cout << "X()" << std::endl; }
    X(const X&) { std::cout << "X(const X&)" << std::endl; }
    X& operator=(const X&) { std::cout << "X& operator=(const X&)" << std::endl; return *this; }
    ~X() { std::cout << "~X()" << std::endl; }
};

void f(const X &rx, X x)
{
    std::vector<X> vec;
    vec.reserve(2);
    vec.push_back(rx);
    vec.push_back(x);
}

int main()
{
    X *px = new X;
    f(*px, *px);
    delete px;

    return 0;
}

```


output:

```
X() //Constructor
X(const X&) // Copy, parameter
X(const X&) // push_back copy
X(const X&) // push_back copy
~X() // vec destructor
~X() // vec destructor
~X() // f's parameter destructor
~X() // px destructor
```

## Exercise 13.14
Numbered will output 3 identical numbers generated by default constructor.


## Exercise 13.15
3 different numbers.

## Exercise 13.16
3 different numbers, but less call to copy constructor.

## Exercise 13.17
Trivial.

## Exercise 13.18
```
class Employ{
public:
	Employ();
	Employ(string name){n = name;}
	Employ(const string na&){name = na;}
	Employ& operator=(const Employ& e){name = e.name; return *this;}
private:
	string name;
	static int increment_id = 10;
	int id;

};
Employ::Employ(){
	id = increment_id++;
}
Employ::Employ(const string& na){
	id = increment_id++;
	name = na;
}
## Exercise 13.19
No. They should be deleted.

Yet sometimes they will be put into collections.


```


## Exercise 13.20

## Exercise 13.21

(@Mooophy) No copy-control members needed.

Because, all these classes are using smart pointers to manage dynamic memory which can be freed automatically by calling synthesized destructors. The objects of these classes should share the same dynamic memory.Hence no user-defined version needed as well.

```
TextQuery(const TextQuery&) = delete;
TextQuery& operator=(const TextQuery) = delete;

QueryResult(const QueryResult&) = delete;
QueryResult& operator=(const QueryResult) = delete;
```

## Exercise 13.22

```
class HasPtr {
public:
    HasPtr(const std::string &s = std::string()) : ps(new std::string(s)), i(0) { }
    HasPtr(const HasPtr &hp) : ps(new std::string(*hp.ps)), i(hp.i) { }
    HasPtr& operator=(const HasPtr &hp) {
        auto new_p = new std::string(*hp.ps);
        delete ps;
        ps = new_p;
        i = hp.i;
        return *this;
    }
    ~HasPtr() {
        delete ps;
    } 
private:
    std::string *ps;
    int i;
};
```

## Exercise 13.23

## Exercise 13.24
No destructor: Memory leak.
No Copy constructor: just pointer copy. Destructor may free memory twice. Other reference my be undefined.

## Exercise 13.25
Copy constructor should allocate memory explicitly.
No destructor needed, as smart pointers automaticly delete object when reference_count decrement to 0.

## Exercise 13.26

## Exercise 13.27

```
class HasPtr {
public:
    HasPtr(const std::string &s = std::string()) : ps(new std::string(s)), i(0), use(new size_t(1)) { }
    HasPtr(const HasPtr &hp) : ps(hp.ps), i(hp.i), use(hp.use) { ++*use; }
    HasPtr& operator=(const HasPtr &rhs) {
        ++*rhs.use;
        if (--*use == 0) {
            delete ps;
            delete use;
        }
        ps = rhs.ps;
        i = rhs.i;
        use = rhs.use;
        return *this;
    }
    ~HasPtr() {
        if (--*use == 0) {
            delete ps;
            delete use;
        }
    } 
private:
    std::string *ps;
    int i;
    size_t *use;
};
```

## Exercise 13.28


```
class TreeNode {
public:
    TreeNode() : value(string()), count(new int(1)), left(nullptr), right(nullptr) {}
    TreeNode(const TreeNode &rhs) : value(rhs.value), count(rhs.count), left(rhs.left), right(rhs.right) { ++*count; }
    TreeNode& operator=(const TreeNode &rhs);
    ~TreeNode() {
        if (--*count == 0) {
            if (left) {
                delete left;
                left = nullptr;
            }
            if (right) {
                delete right;
                right = nullptr;
            }
            delete count;
            count = nullptr;
        }
    }

private:
    std::string value;
    int         *count;
    TreeNode    *left;
    TreeNode    *right;
};

```

## Exercise 13.29
Overloaded functions ensure no recursion loop.
